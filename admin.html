<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tambola 69 - Admin Panel</title>
<style>
  body { 
    font-family: Arial, Helvetica, sans-serif; 
    background: #111; 
    color: #fff; 
    text-align: center; 
    padding: 18px; 
    margin: 0; 
    overflow: hidden; /* Prevent scrolling during animation */
  }
  h1,h2,h3 { color: orange; margin: 10px 0; }
  .section { background: #222; padding: 14px; margin: 12px auto; max-width: 1000px; border-radius: 10px; text-align:left; }
  input, button, select, textarea { font-size: 15px; padding: 8px; margin: 6px 4px; border-radius: 6px; border: none; }
  button { background: orange; color: #000; cursor: pointer; font-weight: 700; }
  button:hover { background:#ff8800; }
  .action-row { display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
  .live-box { background:#000; padding:8px 10px; border-radius:8px; display:inline-block; margin-left:8px; }
  .tambola-board, .ticket-board { display:flex; flex-wrap:wrap; gap:6px; margin-top:8px; }
  .board-cell, .ticket-cell { width:40px; height:40px; display:flex; align-items:center; justify-content:center; background:#333; border-radius:6px; font-weight:bold; color:#fff; cursor:pointer; }
  .board-cell.drawn { background:#000; color:#ff0; }
  .winner-card { background:#000; padding:10px; margin:8px 0; border-radius:8px; }
  .claim-card { background:#1a1a1a; padding:10px; margin:8px 0; border-radius:8px; display:flex; justify-content:space-between; align-items:center; gap:10px; }
  .room-select { background:#111; padding:8px; border-radius:8px; display:flex; gap:8px; align-items:center; }
  .small { font-size:13px; padding:6px; }
  textarea { width:100%; min-height:60px; border-radius:6px; }
  .muted { color:#bbb; font-size:13px; }
  .table-wrap{ overflow:auto; border-radius:8px; border:1px solid #333; }
  table { width:100%; border-collapse: collapse; }
  th, td { padding:8px; border-bottom:1px solid #333; vertical-align: top; text-align:left; }
  th { position: sticky; top:0; background:#1b1b1b; }
  .row-actions button{ margin:0 4px; padding:6px 8px; }
  .w-120{ width:120px; }
  .w-160{ width:160px; }
  .w-220{ width:220px; }
  .w-60{ width:60px; }
  .table-small{ width:100%; border-collapse:collapse; margin-top:8px }
  .table-small th, .table-small td { padding:8px; border-bottom:1px solid #333; font-size:14px; text-align:left }
  .btn-ghost{ background:transparent; border:1px solid #333; color:#fff; padding:6px 8px; border-radius:6px; cursor:pointer }
  .btn-danger{ background:#ff4d4f; color:#fff; padding:6px 8px; border-radius:6px; cursor:pointer; border:none }
  /* New button style for claim reset */
  .btn-reset-claims { background: #337ab7; color: #fff; }
  .btn-reset-claims:hover { background: #286090; }
  /* New button style for all user data clear */
  .btn-clear-all-data { background: #8B0000; color: #fff; } /* Dark Red */
  .btn-clear-all-data:hover { background: #B22222; }

  /* Loading Animation Styles */
  #loading-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(circle at center, #2a1a5e 0%, #0a0a2d 50%, #000 100%); /* Vibrant galaxy gradient */
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    opacity: 1;
    transition: opacity 0.5s ease-out;
    overflow: hidden;
  }
  #loading-screen.hidden {
    opacity: 0;
    pointer-events: none;
  }
  /* Galaxy Stars Effect */
  #loading-screen::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: 
      radial-gradient(white, rgba(255,255,255,.2) 2px, transparent 5px),
      radial-gradient(white, rgba(255,255,255,.15) 1px, transparent 3px),
      radial-gradient(white, rgba(255,255,255,.1) 1px, transparent 2px);
    background-size: 400px 400px, 200px 200px, 150px 150px;
    background-position: 0 0, 50px 50px, 100px 100px;
    animation: twinkle 4s infinite ease-in-out;
  }
  @keyframes twinkle {
    0% { opacity: 0.6; }
    50% { opacity: 1; }
    100% { opacity: 0.6; }
  }
  .welcome-text {
    font-size: 2.5rem;
    font-weight: bold;
    color: #fff;
    text-shadow: 0 0 15px #ff8800, 0 0 25px #ff8800, 0 0 35px #ff8800;
    animation: glow 2s ease-in-out infinite alternate, fadeIn 1.5s ease-in;
    text-align: center;
    padding: 0 20px;
    max-width: 90%;
    font-family: 'Arial', sans-serif;
  }
  #main-content {
    display: none; /* Hide main content initially */
  }
  #main-content.visible {
    display: block; /* Show main content after animation */
  }
  @keyframes glow {
    from {
      text-shadow: 0 0 15px #ff8800, 0 0 25px #ff8800, 0 0 35px #ff8800;
    }
    to {
      text-shadow: 0 0 25px #ff4500, 0 0 35px #ff4500, 0 0 45px #ff4500;
    }
  }
  @keyframes fadeIn {
    from { opacity: 0; transform: scale(0.9); }
    to { opacity: 1; transform: scale(1); }
  }
  @media (max-width: 600px) {
    .welcome-text {
      font-size: 1.6rem;
    }
  }
</style>
</head>
<body>
  <div id="loading-screen">
    <div class="welcome-text">Welcome to Your Own World Manas</div>
  </div>

  <div id="main-content">
    <h1>üéõÔ∏è Tambola 69 - Admin Panel</h1>

    <div class="section">
      <h2>üñºÔ∏è Slider Control</h2>
      <div class="action-row">
        <button onclick="toggleSliderPlay()" id="toggleSliderBtn">‚ñ∂Ô∏è Play</button>
        <button onclick="prevSlide()">‚óÄÔ∏è Previous</button>
        <button onclick="nextSlide()">Next ‚ñ∂Ô∏è</button>
        <button onclick="addSlideRow()">+ Add Slide</button>
      </div>
      <div class="action-row" style="margin-top:8px">
        <input type="number" id="gotoIndexInput" min="0" placeholder="Go to index">
        <button onclick="goToSlide()">Go</button>
        <div class="live-box">Current Index: <span id="currentIndexDisplay">0</span></div>
      </div>
      <div class="action-row" style="margin-top:8px">
        <input type="number" id="speedInput" min="500" placeholder="Speed (ms)">
        <button onclick="setSpeed()">Set Speed</button>
        <div class="live-box">Speed: <span id="speedDisplay">0 ms</span></div>
      </div>
      <div class="table-wrap" style="margin-top:10px">
        <table>
          <thead>
            <tr>
              <th>Action</th>
              <th>Image URL</th>
              <th>Link URL</th>
              <th>Title</th>
              <th>Button</th>
              <th>Size (Optional)</th>
            </tr>
          </thead>
          <tbody id="slidesTbody"></tbody>
        </table>
      </div>
      <div style="display:flex; justify-content:space-between; align-items:center; margin-top:10px;">
        <div class="muted">Total Slides: <span id="slidesCount">0</span></div>
        <button onclick="saveSlidesAdvanced()">üíæ Save All Slides to DB</button>
      </div>
    </div>

    <div class="section">
      <h2>üéµ Music Control</h2>
      <input type="text" id="musicUrlInput" placeholder="Enter music stream URL" style="width:70%">
      <button onclick="saveMusicUrl()">Save URL</button>
      <button id="toggleMusicBtn" onclick="toggleMusic()">‚ñ∂Ô∏è Play</button>
      <div class="muted" style="margin-top:6px">Clients will auto-play if their local mute is off.</div>
    </div>

    <div class="section">
      <h2>üé¨ ‡§µ‡•Ä‡§°‡§ø‡§Ø‡•ã ‡§ï‡§Ç‡§ü‡•ç‡§∞‡•ã‡§≤</h2>
      <input type="text" id="videoUrlInput" placeholder="‡§µ‡•Ä‡§°‡§ø‡§Ø‡•ã ‡§∏‡•ç‡§ü‡•ç‡§∞‡•Ä‡§Æ URL ‡§°‡§æ‡§≤‡•á‡§Ç" style="width:70%">
      <button onclick="saveVideoUrl()">URL ‡§∏‡•á‡§µ ‡§ï‡§∞‡•á‡§Ç</button>
      <button id="toggleVideoBtn" onclick="toggleVideo()">‚ñ∂Ô∏è ‡§™‡•ç‡§≤‡•á</button>
      <div class="muted" style="margin-top:6px">‡§ï‡•ç‡§≤‡§æ‡§á‡§Ç‡§ü‡•ç‡§∏ ‡§µ‡•Ä‡§°‡§ø‡§Ø‡•ã ‡§ë‡§ü‡•ã-‡§™‡•ç‡§≤‡•á ‡§ï‡§∞‡•á‡§Ç‡§ó‡•á ‡§Ö‡§ó‡§∞ ‡§â‡§®‡§ï‡§æ ‡§Æ‡•ç‡§Ø‡•Ç‡§ü ‡§ë‡§´ ‡§π‡•à‡•§</div>
    </div>

    <div class="section">
      <h2>üì¢ Notifications</h2>
      <div style="display:flex;gap:8px;align-items:center;">
        <input id="notifyTo" type="text" placeholder="User ID (leave empty for broadcast) - e.g. user123" style="width:40%">
        <label style="display:flex;align-items:center;gap:6px;"><input id="notifyBroadcast" type="checkbox"> Broadcast to all</label>
      </div>
      <textarea id="notifyMessage" placeholder="Enter message for users..."></textarea>
      <div style="display:flex;gap:8px;">
        <button onclick="sendNotification()">Send Notification</button>
      </div>
      <div class="muted" style="margin-top:8px">Notifications are pushed to <code>/notifications</code>. For specific users also stored under <code>/userNotifications/{userId}</code>.</div>
    </div>

    <div class="section">
      <h2>üéÅ Prize Management</h2>
      <div id="prizeManagementContainer"></div>
      <button onclick="savePrizes()">üíæ Save Prizes</button>
      <div id="prizeUpdateMessage" class="muted" style="margin-top:8px;"></div>
    </div>

    <div class="section">
      <h2>üü¢ Current Game (Frontend Game Start In Box Update)</h2>
      <div class="action-row">
        <button onclick="startGame('current')">Start Game</button>
        <button onclick="stopGame('current')">Stop Game</button>
        <button onclick="resetGame('current')">Reset Game</button>
        <div class="live-box">Status: <span id="currentStatusDisplay">idle</span></div>
        <div class="live-box">Live Users: <span id="liveUserCountDisplay">0</span></div>
      </div>
      <div class="action-row" style="margin-top:10px; margin-bottom:10px;">
        <button onclick="clearGameClaimsAndTickets('current')" class="btn-reset-claims">
          üîÑ Clear Claims & Enable New Ticket Booking
        </button>
      </div>
      <div style="margin-top:8px">
        <input id="currentPrizeInput" type="number" min="1" max="100" placeholder="Prize %"><button onclick="updatePrize('current')">Update Prize</button>
        <div class="live-box">Prize: <span id="currentPrizeDisplay">0%</span></div>
      </div>
      <div style="margin-top:8px">
        <input id="currentTicketsInput" type="number" min="0" placeholder="Tickets Left"><button onclick="updateTickets('current')">Update Tickets</button>
        <div class="live-box">Tickets Left: <span id="currentTicketsDisplay">0</span></div>
      </div>
      <div style="margin-top:8px">
        <input id="currentSpotsInput" type="number" min="0" placeholder="Total Spots"><button onclick="updateSpots('current')">Update Spots</button>
        <div class="live-box">Total Spots: <span id="currentSpotsDisplay">0</span></div>
      </div>
      <div style="margin-top:8px">
        <label for="currentCountdownInput_hms">Countdown (HH:MM:SS):</label>
        <input id="currentCountdownInput_h" type="number" min="0" placeholder="HH" class="small w-60">
        <input id="currentCountdownInput_m" type="number" min="0" max="59" placeholder="MM" class="small w-60">
        <input id="currentCountdownInput_s" type="number" min="0" max="59" placeholder="SS" class="small w-60">
        <button onclick="updateCountdown('current')">Update Countdown</button>
        <div class="live-box">Countdown: <span id="currentCountdownDisplay">00:00:00</span></div>
      </div>
      <div class="action-row" style="margin-top:8px">
        <input id="currentNumberInput" type="number" min="1" max="90" placeholder="Draw Number">
        <button onclick="broadcastNumber('current')">Broadcast Number</button>
        <button onclick="autoDrawNumber('current')">Auto Draw Every 30s</button>
      </div>
      <h3>Tambola Board</h3>
      <div id="currentTambolaBoard" class="tambola-board"></div>
      <h3>üèÜ Winners</h3>
      <div id="currentWinnersForm"></div>
      <button onclick="saveAllWinners('current')">Update All Winners</button>
      <h3>‚úÖ Claims</h3>
      <div id="currentClaimsList"></div>
      
      <h3>üé´ User Tickets Sold (View All)</h3>
      <div id="currentTicketsList"></div>
      </div>

    <div class="section">
      <h2>üü° Next Game (Frontend Next Game Start In Box Control)</h2>
      <div class="action-row">
        <button onclick="startGame('next')">Start Game</button>
        <button onclick="stopGame('next')">Stop Game</button>
        <button onclick="resetGame('next')">Reset Game</button>
        <div class="live-box">Status: <span id="nextStatusDisplay">idle</span></div>
      </div>
      <div style="margin-top:8px">
        <input id="nextPrizeInput" type="number" min="1" max="100" placeholder="Prize %"><button onclick="updatePrize('next')">Update Prize</button>
        <div class="live-box">Prize: <span id="nextPrizeDisplay">0%</span></div>
      </div>
      <div style="margin-top:8px">
        <input id="nextTicketsInput" type="number" min="0" placeholder="Tickets Left"><button onclick="updateTickets('next')">Update Tickets</button>
        <div class="live-box">Tickets Left: <span id="nextTicketsDisplay">0</span></div>
      </div>
      <div style="margin-top:8px">
        <input id="nextSpotsInput" type="number" min="0" placeholder="Total Spots"><button onclick="updateSpots('next')">Update Spots</button>
        <div class="live-box">Total Spots: <span id="nextSpotsDisplay">0</span></div>
      </div>
      <div style="margin-top:8px">
        <label for="nextCountdownInput_hms">Countdown (HH:MM:SS):</label>
        <input id="nextCountdownInput_h" type="number" min="0" placeholder="HH" class="small w-60">
        <input id="nextCountdownInput_m" type="number" min="0" max="59" placeholder="MM" class="small w-60">
        <input id="nextCountdownInput_s" type="number" min="0" max="59" placeholder="SS" class="small w-60">
        <button onclick="updateCountdown('next')">Update Countdown</button>
        <div class="live-box">Countdown: <span id="nextCountdownDisplay">00:00:00</span></div>
      </div>
      <div class="action-row" style="margin-top:8px">
        <input id="nextNumberInput" type="number" min="1" max="90" placeholder="Draw Number">
        <button onclick="broadcastNumber('next')">Broadcast Number</button>
        <button onclick="autoDrawNumber('next')">Auto Draw Every 30s</button>
      </div>
      <h3>Tambola Board</h3>
      <div id="nextTambolaBoard" class="tambola-board"></div>
      <h3>üèÜ Winners</h3>
      <div id="nextWinnersForm"></div>
      <button onclick="saveAllWinners('next')">Update All Winners</button>
      <h3>‚úÖ Claims</h3>
      <div id="nextClaimsList"></div>
      <h3>üé´ User Tickets Sold (View All)</h3>
      <div id="nextTicketsList"></div>
    </div>

    <div class="section">
      <h2>üéÆ Play With Friends</h2>
      <div class="action-row">
        <button onclick="startGame('friends')">Start Game</button>
        <button onclick="stopGame('friends')">Stop Game</button>
        <button onclick="resetGame('friends')">Reset Game</button>
        <div class="live-box">Status: <span id="friendsStatusDisplay">idle</span></div>
      </div>
      <div style="margin-top:8px">
        <input id="friendsPrizeInput" type="number" min="1" max="100" placeholder="Prize %"><button onclick="updatePrize('friends')">Update Prize</button>
        <div class="live-box">Prize: <span id="friendsPrizeDisplay">0%</span></div>
      </div>
      <div style="margin-top:8px">
        <input id="friendsSpotsInput" type="number" min="0" placeholder="Total Spots"><button onclick="updateSpots('friends')">Update Spots</button>
        <div class="live-box">Total Spots: <span id="friendsSpotsDisplay">0</span></div>
      </div>
      <div style="margin-top:8px">
        <label for="friendsCountdownInput_hms">Countdown (HH:MM:SS):</label>
        <input id="friendsCountdownInput_h" type="number" min="0" placeholder="HH" class="small w-60">
        <input id="friendsCountdownInput_m" type="number" min="0" max="59" placeholder="MM" class="small w-60">
        <input id="friendsCountdownInput_s" type="number" min="0" max="59" placeholder="SS" class="small w-60">
        <button onclick="updateCountdown('friends')">Update Countdown</button>
        <div class="live-box">Countdown: <span id="friendsCountdownDisplay">00:00:00</span></div>
      </div>
      <div class="action-row" style="margin-top:8px">
        <input id="friendsNumberInput" type="number" min="1" max="90" placeholder="Draw Number">
        <button onclick="broadcastNumber('friends')">Broadcast Number</button>
        <button onclick="autoDrawNumber('friends')">Auto Draw Every 30s</button>
      </div>
      <div class="room-select" style="margin-top:10px">
        <input type="text" id="roomSearch" onkeyup="filterRooms()" placeholder="üîç Search Room...">
        <select id="roomDropdown" onchange="changeRoom()"></select>
      </div>
      <h3>Tambola Board</h3>
      <div id="friendsTambolaBoard" class="tambola-board"></div>
      <h3>üèÜ Winners</h3>
      <div id="friendsWinnersForm"></div>
      <button onclick="saveAllWinners('friends')">Update All Winners</button>
      <h3>‚úÖ Claims</h3>
      <div id="friendsClaimsList"></div>
      <h3>üé´ User Tickets Sold (View All)</h3>
      <div id="friendsTicketsList"></div>
    </div>

    <div class="section">
      <h2>üí∞ Withdrawal Requests</h2>
      <div class="table-wrap"><div id="withdrawalsList" class="muted">Loading withdrawals...</div></div>
    </div>

    <div class="section">
      <h2>üë• Users & Balance</h2>
      <div id="usersTicketsList" class="muted">Loading users & tickets...</div>
    </div>

    <div class="section">
      <h2>üèÜ Claims</h2>
      <button id="toggleClaimsButton" onclick="toggleClaimsView()">View All Claims</button>
      <div id="claimsList" class="muted">Loading claims...</div>
    </div>

    <div class="section">
      <h2>‚öôÔ∏è Quick admin</h2>
      <div class="action-row">
        <div class="live-box">Total Tickets Sold: <span id="totalTicketsSoldDisplay">0</span></div>
        <button onclick="generateBoard('current')">Regenerate Current Board UI</button>
        <button onclick="generateBoard('next')">Regenerate Next Board UI</button>
        <button onclick="generateBoard('friends')">Regenerate Friends Board UI</button>
        <button onclick="endAllGamesAndResetTickets()" style="background:#ff4d4f;">üõë Game Over & Reset Tickets</button>
        <button onclick="startNewGameForAll()" style="background:#32CD32;">üöÄ Start New Game</button>
        <button onclick="startNewRoundAfterGameOver()" style="background: #FFD700; color: #000;">üü° Start New Round</button> <button onclick="clearAllUserData()" class="btn-clear-all-data">üõë Clear All User Data</button> </div>
    </div>
  </div>

<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
<script>
// Firebase Configuration - REPLACE WITH YOUR FIREBASE PROJECT DETAILS
const firebaseConfig = {
apiKey: "AIzaSyBna8v2aVHVPwvHN4CeV3yRdY3eU3MwXYE",
      authDomain: "tambola69-d0f60.firebaseapp.com",
      databaseURL: "https://tambola69-d0f60-default-rtdb.firebaseio.com",
      projectId: "tambola69-d0f60",
      storageBucket: "tambola69-d0f60.firebasestorage.app",
      messagingSenderId: "156287171993",
      appId: "1:156287171993:web:1ad728a677ea5c4df8e708",
      measurementId: "G-SY7WL73GRZ"
};

// Initialize Firebase with error handling
let db;
try {
  if (!firebase.apps.length) {
    firebase.initializeApp(firebaseConfig);
    console.log("Firebase connection successful!");
  } else {
    console.log("Firebase app already running.");
  }
  db = firebase.database();
} catch (e) {
  console.error("Firebase initialization failed:", e);
  alert("Firebase setup issue. Admin panel will load without Firebase features.");
}

// Firebase references (only if Firebase is initialized)
const currentGameRef = db ? db.ref('currentGame') : null;
const nextGameRef = db ? db.ref('nextGame') : null;
const presenceRef = db ? db.ref('presence') : null;
const roomsRef = db ? db.ref('rooms') : null;
let selectedRoom = "Room1";
let friendsGameRef = roomsRef ? roomsRef.child(selectedRoom) : null;
const musicRef = db ? db.ref("music") : null;
const videoRef = db ? db.ref("video") : null;
const sliderRef = db ? db.ref('slider') : null;
const prizesRef = db ? db.ref('prizes') : null;
const userTicketsRef = db ? db.ref('userTickets') : null; // Added reference to userTickets
const globalClaimsRef = db ? db.ref('claims') : null; // Added global claims ref
const usersRef = db ? db.ref('users') : null; // Added reference to users node
const withdrawalsRef = db ? db.ref('withdrawals') : null; // Added reference to withdrawals node
const userNotificationsRef = db ? db.ref('userNotifications') : null; // Added reference for user-specific notifications
const transactionsRef = db ? db.ref('transactions') : null; // Assuming a 'transactions' or 'paymentHistory' node

let localSlides = [];
const autoTimers = { current: null, next: null, friends: null };
let showAllClaims = false;

let countdownIntervals = {
  current: null,
  next: null,
  friends: null
};

const listeners = {
  current: {},
  next: {},
  friends: {},
  globalClaims: null,
  globalWithdrawals: null,
  globalUsers: null
};

/**
 * Gets the correct Firebase reference based on the game key.
 * @param {string} key - The game key ('current', 'next', 'friends').
 * @returns {firebase.database.Reference | null} The Firebase reference.
 */
function refFor(key) {
  if (key === 'current') return currentGameRef; // Frontend Game Start In Box Update
  if (key === 'next') return nextGameRef; // Frontend Next Game Start In Box Control
  if (key === 'friends') return friendsGameRef;
  return null;
}

// --- NEW FUNCTION TO CLEAR ALL USER-RELATED DATA ---
/**
 * Clears all user-specific data from the database.
 * This includes: users (balance, profile), userTickets, claims, withdrawals, userNotifications, and transactions.
 */
function clearAllUserData() {
    if (!db) return alert("Firebase not initialized.");

    if (!confirm("‚ö†Ô∏è DANGER: ‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§∏‡§ö ‡§Æ‡•á‡§Ç ‡§∏‡§≠‡•Ä ‡§Ø‡•Ç‡§ú‡§º‡§∞‡•ç‡§∏ ‡§ï‡§æ **‡§∏‡§æ‡§∞‡§æ ‡§°‡•á‡§ü‡§æ** (‡§Ø‡•Ç‡§ú‡§º‡§∞ ‡§™‡•ç‡§∞‡•ã‡§´‡§º‡§æ‡§á‡§≤, ‡§¨‡•à‡§≤‡•á‡§Ç‡§∏, ‡§ü‡§ø‡§ï‡§ü, ‡§™‡•á‡§Æ‡•á‡§Ç‡§ü ‡§π‡§ø‡§∏‡•ç‡§ü‡•ç‡§∞‡•Ä, ‡§µ‡§ø‡§•‡§°‡•ç‡§∞‡•â‡§≤, ‡§ï‡•ç‡§≤‡•á‡§Æ) ‡§π‡§Æ‡•á‡§∂‡§æ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§π‡§ü‡§æ‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç? ‡§Ø‡§π ‡§ï‡•ç‡§∞‡§ø‡§Ø‡§æ ‡§™‡•Ç‡§∞‡•ç‡§µ‡§µ‡§§ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡•Ä ‡§ú‡§æ ‡§∏‡§ï‡§§‡•Ä‡•§")) {
        return;
    }

    const clearPromises = [];
    
    // Nodes to clear
    const nodesToClear = {
        'Users & Balance (users)': usersRef,
        'User Tickets (userTickets)': userTicketsRef,
        'Global Claims (claims)': globalClaimsRef,
        'Withdrawal Requests (withdrawals)': withdrawalsRef,
        'User Notifications (userNotifications)': userNotificationsRef,
        'Transactions/Payment History (transactions)': transactionsRef, // Assuming this node exists for history
        'Rooms Data (rooms)': roomsRef // Optional: clear all rooms data
    };
    
    // Clear the main nodes
    for (const key in nodesToClear) {
        if (nodesToClear[key]) {
            clearPromises.push(
                nodesToClear[key].remove()
                    .then(() => `‚úÖ ${key} cleared.`)
                    .catch(e => {
                        console.error(`Error clearing ${key}:`, e);
                        return `‚ùå Error clearing ${key}: ${e.message}`;
                    })
            );
        } else {
             // If a ref is null (like transactionsRef if you don't use it), just log
            clearPromises.push(Promise.resolve(`‚ö†Ô∏è Node not found/not used: ${key}. Skipping.`));
        }
    }
    
    // Also stop and reset all games (current, next, friends) to an idle state without any data
    const gameKeys = ['current', 'next', 'friends'];
    const gameRefs = gameKeys.map(refFor).filter(ref => ref !== null);
    
    const gameClearPromises = gameRefs.map(ref => {
        clearInterval(autoTimers[ref.key]); // Stop auto-draw if running
        clearInterval(countdownIntervals[ref.key]); // Stop countdown
        return ref.update({
            status: 'idle', 
            liveNumber: null, 
            countdown: null, 
            ticketsLeft: null, 
            totalSpots: null, 
            history: null, 
            winners: null, 
            claims: null, 
            tickets: null // Ensure game-specific tickets are also cleared
        }).then(() => {
             updateStatusUI(ref.key, 'idle');
             return `‚úÖ Game ${ref.key} fully reset.`;
        });
    });
    
    // Add game resets to the main promises array
    clearPromises.push(...gameClearPromises);
    
    // Send a final notification (since the notifications node is not cleared, only userNotifications)
    const notificationPromise = db.ref('notifications').push({
        message: 'Admin has performed a full data reset. Please register/login again.',
        time: firebase.database.ServerValue.TIMESTAMP
    }).then(() => '‚úÖ Global notification sent about the reset.');

    clearPromises.push(notificationPromise);

    Promise.all(clearPromises)
        .then(results => {
            console.log("Full Data Clear Results:", results);
            alert(`üõë FULL DATA CLEAR COMPLETE! üõë\n\n‡§∏‡§≠‡•Ä ‡§Ø‡•Ç‡§ú‡§º‡§∞ ‡§ï‡§æ ‡§°‡•á‡§ü‡§æ ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§π‡§ü‡§æ ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§\n\nDetails: \n` + results.join('\n'));
        })
        .catch(e => {
            console.error("CRITICAL ERROR during full data clear:", e);
            alert("‚ùå CRITICAL ERROR: ‡§°‡•á‡§ü‡§æ ‡§ï‡•ç‡§≤‡§ø‡§Ø‡§∞ ‡§ï‡§∞‡§§‡•á ‡§∏‡§Æ‡§Ø ‡§è‡§ï ‡§ó‡§Ç‡§≠‡•Ä‡§∞ ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø ‡§π‡•Å‡§à‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ Firebase ‡§ï‡§Ç‡§∏‡•ã‡§≤ ‡§ú‡§æ‡§Ç‡§ö‡•á‡§Ç‡•§ " + e.message);
        });
}
// --- END NEW FUNCTION ---

// --- EXISTING FUNCTIONS (Unchanged logic, kept for context) ---

/**
 * Clears game-specific claims, global claims, and game-specific tickets,
 * enabling new ticket generation for the specified game.
 * @param {string} game - The game key ('current', 'next', 'friends').
 */
function clearGameClaimsAndTickets(game) {
    if (!db) return alert("Firebase not initialized.");
    const gameRef = refFor(game);
    if (!gameRef) return alert('Invalid game key');

    if (!confirm(`‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§∏‡§ö ‡§Æ‡•á‡§Ç ${game.toUpperCase()} ‡§ó‡•á‡§Æ ‡§ï‡•á ‡§∏‡§≠‡•Ä ‡§™‡§ø‡§õ‡§≤‡•á 'claims' (‡§ó‡•á‡§Æ-‡§∏‡•ç‡§™‡•á‡§∏‡§ø‡§´‡§º‡§ø‡§ï ‡§î‡§∞ ‡§ó‡•ç‡§≤‡•ã‡§¨‡§≤ ‡§¶‡•ã‡§®‡•ã‡§Ç) ‡§î‡§∞ 'tickets' ‡§π‡§ü‡§æ‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç? ‡§ê‡§∏‡§æ ‡§ï‡§∞‡§®‡•á ‡§∏‡•á ‡§â‡§™‡§Ø‡•ã‡§ó‡§ï‡§∞‡•ç‡§§‡§æ ‡§®‡§è ‡§ü‡§ø‡§ï‡§ü ‡§¨‡•Å‡§ï ‡§ï‡§∞ ‡§™‡§æ‡§è‡§Ç‡§ó‡•á ‡§î‡§∞ ‡§â‡§®‡•ç‡§π‡•á‡§Ç 'already claimed' ‡§ï‡•Ä ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§®‡§π‡•Ä‡§Ç ‡§Ü‡§è‡§ó‡•Ä‡•§`)) {
        return;
    }

    // 1. Clear game-specific claims and tickets
    const gameUpdatePromise = gameRef.update({
        claims: null, // Clear game-specific claims
        tickets: null // Clear tickets booked for this specific game
    }).then(() => `‚úÖ Game ${game} claims and tickets cleared.`);

    // 2. Clear the global 'claims' node to ensure all previous claims are removed (FIX FOR "ALREADY CLAIMED")
    const claimsClearPromise = globalClaimsRef.remove()
        .then(() => '‚úÖ Global claims cleared successfully (Users will no longer see "already claimed").')
        .catch(e => {
            console.error("Error clearing claims:", e);
            return `‚ùå Error clearing global claims: ${e.message}`;
        });
        
    // 3. Send a notification to inform users
    const notificationPromise = db.ref('notifications').push({
        message: `New round for ${game.toUpperCase()} started! All previous claims/tickets cleared. Book new tickets now!`,
        time: firebase.database.ServerValue.TIMESTAMP
    }).then(() => '‚úÖ Notification sent.');

    Promise.all([gameUpdatePromise, claimsClearPromise, notificationPromise])
        .then(results => {
            console.log("Clear Claims & New Ticket results:", results);
            alert(`‚úÖ ${game.toUpperCase()} Claims/Tickets Reset Complete!\n\nDetails: \n` + results.join('\n'));
        })
        .catch(e => {
            console.error("Critical error during claims/tickets reset:", e);
            alert("‚ùå CRITICAL ERROR during claims/tickets reset: " + e.message + ". Please check Firebase console.");
        });
}
// --- END NEW FUNCTION ---

// --- UPDATED FUNCTION TO START ALL GAMES AFTER RESET (Includes claims reset) ---
/**
 * Starts all games (current, next, and current friends room) and resets necessary data.
 */
function startNewGameForAll() {
    if (!db) return alert("Firebase not initialized.");

    if (!confirm("‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§∏‡§ö ‡§Æ‡•á‡§Ç ‡§∏‡§≠‡•Ä ‡§ó‡•á‡§Æ‡•ç‡§∏ (Current, Next, Friends) ‡§ï‡•ã 'Started' ‡§∏‡•ç‡§•‡§ø‡§§‡§ø ‡§Æ‡•á‡§Ç ‡§∏‡•á‡§ü ‡§ï‡§∞‡§ï‡•á ‡§®‡§Ø‡§æ ‡§ó‡•á‡§Æ ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç?")) {
        return;
    }

    const gameKeys = ['current', 'next', 'friends'];
    const gameRefs = gameKeys.map(refFor).filter(ref => ref !== null);
    
    // 1. Update status to 'started' and clear history/claims/winners/tickets for all active games
    const gameUpdatePromises = gameRefs.map(ref => {
        clearInterval(autoTimers[ref.key]); // Stop auto-draw if running
        clearInterval(countdownIntervals[ref.key]); // Stop countdown
        return ref.update({
            status: 'started',
            liveNumber: null,
            countdown: 0, // Reset countdown to 0
            history: null,
            claims: null, // <<-- ‡§ó‡•á‡§Æ-‡§∏‡•ç‡§™‡•á‡§∏‡§ø‡§´‡§º‡§ø‡§ï ‡§ï‡•ç‡§≤‡•á‡§Æ ‡§∞‡•Ä‡§∏‡•á‡§ü
            winners: null,
            tickets: null, // ‡§™‡§ø‡§õ‡§≤‡•á ‡§ñ‡§∞‡•Ä‡§¶‡•á ‡§ó‡§è ‡§ü‡§ø‡§ï‡§ü ‡§π‡§ü‡§æ‡§è
            startTime: firebase.database.ServerValue.TIMESTAMP // Set new start time
        }).then(() => {
             updateStatusUI(ref.key, 'started');
             return `Game ${ref.key} updated to 'started' and history/claims/winners cleared.`;
        });
    });
    
    // 2. Clear the global 'claims' node to ensure all previous claims are removed (FIX FOR "ALREADY CLAIMED")
    const claimsClearPromise = globalClaimsRef.remove() // Using the new globalClaimsRef
        .then(() => 'Global claims cleared successfully (Users will no longer see "already claimed").')
        .catch(e => {
            console.error("Error clearing claims:", e);
            return `Error clearing global claims: ${e.message}`;
        });
        
    // 3. Send a notification to all users about the new game
    const notificationPromise = db.ref('notifications').push({
        message: 'New Game Started! Book your tickets now!',
        time: firebase.database.ServerValue.TIMESTAMP
    }).then(() => 'Start new game notification sent.');

    Promise.all([...gameUpdatePromises, claimsClearPromise, notificationPromise])
        .then(results => {
            console.log("Start New Game results:", results);
            alert("‚úÖ New Game Started Successfully! Users can now book new tickets. \n\nDetails: \n" + results.join('\n'));
        })
        .catch(e => {
            console.error("Critical error during start new game:", e);
            alert("‚ùå CRITICAL ERROR during start new game: " + e.message + ". Please check Firebase console.");
        });
}
// --- END UPDATED FUNCTION ---


// --- NEW FUNCTION: Start New Round after Game Over ---
/**
 * Stops all games (current, next, and current friends room), sets status to 'idle',
 * clears all booked tickets for those games, and resets the global 'userTickets' node AND 'claims' node.
 * This is for a soft reset after a game is officially over, allowing new tickets to be booked.
 */
function startNewRoundAfterGameOver() {
    if (!db) return alert("Firebase not initialized.");

    if (!confirm("‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§∏‡§≠‡•Ä ‡§ó‡•á‡§Æ‡•ç‡§∏ (Current, Next, Friends) ‡§ï‡•ã 'idle' ‡§™‡§∞ ‡§∞‡•Ä‡§∏‡•á‡§ü ‡§ï‡§∞‡§ï‡•á **‡§®‡§Ø‡§æ ‡§∞‡§æ‡§â‡§Ç‡§°** ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç? ‡§á‡§∏‡§∏‡•á ‡§∏‡§≠‡•Ä ‡§ó‡•á‡§Æ‡•ç‡§∏ ‡§ï‡•á ‡§ü‡§ø‡§ï‡§ü, ‡§ï‡•ç‡§≤‡•á‡§Æ‡•ç‡§∏, ‡§î‡§∞ ‡§π‡§ø‡§∏‡•ç‡§ü‡•ç‡§∞‡•Ä ‡§π‡§ü ‡§ú‡§æ‡§è‡§Ç‡§ó‡•á ‡§î‡§∞ ‡§Ø‡•Ç‡§ú‡§º‡§∞ ‡§®‡§Ø‡§æ ‡§ü‡§ø‡§ï‡§ü ‡§¨‡•Å‡§ï ‡§ï‡§∞ ‡§™‡§æ‡§è‡§Ç‡§ó‡•á‡•§")) {
        return;
    }

    const gameKeys = ['current', 'next', 'friends'];
    const gameRefs = gameKeys.map(refFor).filter(ref => ref !== null);
    
    // 1. Update status to 'idle' and clear tickets/history/claims/winners for all active games
    const gameUpdatePromises = gameRefs.map(ref => {
        clearInterval(autoTimers[ref.key]); // Stop auto-draw if running
        clearInterval(countdownIntervals[ref.key]); // Stop countdown
        return ref.update({
            status: 'idle', // Set to idle so admin can officially 'start' it later, but tickets can be booked (based on your game logic)
            liveNumber: null,
            countdown: null,
            history: null,
            claims: null,
            winners: null,
            tickets: null // Clear tickets booked for this specific game
        }).then(() => {
             updateStatusUI(ref.key, 'idle');
             return `Game ${ref.key} updated to 'idle' and game tickets cleared.`;
        });
    });

    // 2. Clear the main userTickets node (where all tickets for all games/demos are stored for users)
    const userTicketsClearPromise = userTicketsRef.remove()
        .then(() => 'Global userTickets cleared successfully (Users can book new tickets).')
        .catch(e => {
            console.error("Error clearing userTickets:", e);
            return `Error clearing global userTickets: ${e.message}`;
        });
        
    // 3. Clear the global 'claims' node to remove pending claims from previous games (FIX FOR "ALREADY CLAIMED")
    const claimsClearPromise = globalClaimsRef.remove()
        .then(() => 'Global claims cleared successfully (Users will no longer see "already claimed").')
        .catch(e => {
            console.error("Error clearing claims:", e);
            return `Error clearing global claims: ${e.message}`;
        });
        
    // 4. Send a notification to all users about the new round
    const notificationPromise = db.ref('notifications').push({
        message: 'New Round Available! Old tickets are cleared. Book your new tickets now!',
        time: firebase.database.ServerValue.TIMESTAMP
    }).then(() => 'New Round notification sent.');

    Promise.all([...gameUpdatePromises, userTicketsClearPromise, claimsClearPromise, notificationPromise])
        .then(results => {
            console.log("New Round Reset results:", results);
            alert("‚úÖ New Round Started and Reset Complete! Users can now book new tickets. \n\nDetails: \n" + results.join('\n'));
        })
        .catch(e => {
            console.error("Critical error during new round reset:", e);
            alert("‚ùå CRITICAL ERROR during new round reset: " + e.message + ". Please check Firebase console.");
        });
}
// --- END NEW FUNCTION ---


// --- UPDATED FUNCTION TO END ALL GAMES AND RESET TICKETS (FIX FOR "ALREADY CLAIMED") ---
/**
 * Stops all games (current, next, and current friends room), sets status to 'gameOver',
 * clears all booked tickets for those games, and resets the global 'userTickets' node AND 'claims' node.
 */
function endAllGamesAndResetTickets() {
    if (!db) return alert("Firebase not initialized.");

    if (!confirm("‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§∏‡§ö ‡§Æ‡•á‡§Ç ‡§∏‡§≠‡•Ä ‡§ó‡•á‡§Æ‡•ç‡§∏ (Current, Next, Friends) ‡§ï‡•ã 'Game Over' ‡§ï‡§∞‡§ï‡•á ‡§â‡§®‡§ï‡•á ‡§î‡§∞ ‡§∏‡§≠‡•Ä users ‡§ï‡•á tickets ‡§ï‡•ã reset ‡§ï‡§∞‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç? ‡§Ø‡§π ‡§°‡•á‡§ü‡§æ Permanent ‡§°‡§ø‡§≤‡•Ä‡§ü ‡§ï‡§∞ ‡§¶‡•á‡§ó‡§æ‡•§ ‡§∏‡§æ‡§• ‡§π‡•Ä, ‡§Ø‡§π users ‡§ï‡•á 'claims' ‡§°‡•á‡§ü‡§æ ‡§ï‡•ã ‡§≠‡•Ä ‡§π‡§ü‡§æ ‡§¶‡•á‡§ó‡§æ, ‡§ú‡§ø‡§∏‡§∏‡•á ‡§â‡§®‡•ç‡§π‡•á‡§Ç 'already claimed' ‡§ï‡•Ä ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§®‡§π‡•Ä‡§Ç ‡§Ü‡§è‡§ó‡•Ä‡•§")) {
        return;
    }

    const gameKeys = ['current', 'next', 'friends'];
    const gameRefs = gameKeys.map(refFor).filter(ref => ref !== null);
    
    // 1. Update status to 'gameOver' and clear tickets/history/claims/winners for all active games
    const gameUpdatePromises = gameRefs.map(ref => {
        clearInterval(autoTimers[ref.key]); // Stop auto-draw if running
        clearInterval(countdownIntervals[ref.key]); // Stop countdown
        return ref.update({
            status: 'gameOver',
            liveNumber: null,
            countdown: 0,
            history: null,
            claims: null,
            winners: null,
            tickets: null // Clear tickets booked for this specific game
        }).then(() => {
             updateStatusUI(ref.key, 'gameOver');
             return `Game ${ref.key} updated to 'gameOver' and game tickets cleared.`;
        });
    });

    // 2. Clear the main userTickets node (where all tickets for all games/demos are stored for users)
    const userTicketsClearPromise = userTicketsRef.remove()
        .then(() => 'Global userTickets cleared successfully (Users can book new tickets).')
        .catch(e => {
            console.error("Error clearing userTickets:", e);
            return `Error clearing global userTickets: ${e.message}`;
        });
        
    // 3. Clear the global 'claims' node to remove pending claims from previous games (FIX FOR "ALREADY CLAIMED")
    // This is the core fix to prevent users from seeing "already claimed" from a previous game.
    const claimsClearPromise = globalClaimsRef.remove() // Using the new globalClaimsRef
        .then(() => 'Global claims cleared successfully (Users will no longer see "already claimed").')
        .catch(e => {
            console.error("Error clearing claims:", e);
            return `Error clearing global claims: ${e.message}`;
        });
        
    // 4. Send a notification to all users about the game reset
    const notificationPromise = db.ref('notifications').push({
        message: 'Game Over! All tickets reset. Please wait for the Admin to start a new game.',
        time: firebase.database.ServerValue.TIMESTAMP
    }).then(() => 'Reset notification sent.');

    Promise.all([...gameUpdatePromises, userTicketsClearPromise, claimsClearPromise, notificationPromise])
        .then(results => {
            console.log("Reset results:", results);
            alert("‚úÖ Game Over and Reset Complete! Users must now wait for 'Start New Game' to book tickets. \n\nDetails: \n" + results.join('\n'));
        })
        .catch(e => {
            console.error("Critical error during reset:", e);
            alert("‚ùå CRITICAL ERROR during reset: " + e.message + ". Please check Firebase console.");
        });
}
// --- END UPDATED FUNCTION ---


function startCountdown(key, duration) {
  if (!db) return;
  let timerRef = refFor(key).child('countdown');
  let timeLeft = duration;
  
  clearInterval(countdownIntervals[key]);

  countdownIntervals[key] = setInterval(() => {
    timeLeft--;
    timerRef.set(timeLeft).catch(e => console.error(`Error updating countdown for ${key}:`, e));
    if (timeLeft <= 0) {
      clearInterval(countdownIntervals[key]);
      timerRef.set(0);
    }
  }, 1000);
}

function saveMusicUrl() {
  if (!db) return alert("Firebase not initialized.");
  const url = document.getElementById("musicUrlInput").value.trim();
  if (!url) return alert("Enter music URL first");
  musicRef.update({ url })
    .then(() => alert("Music URL updated ‚úÖ"))
    .catch(e => alert("Error updating music URL: " + e.message));
}

async function toggleMusic() {
  if (!db) return alert("Firebase not initialized.");
  const snap = await musicRef.once("value");
  const data = snap.val() || {};
  const newState = !data.isPlaying;
  musicRef.update({ isPlaying: newState })
    .catch(e => alert("Error toggling music: " + e.message));
}

function saveVideoUrl() {
  if (!db) return alert("Firebase not initialized.");
  const url = (document.getElementById('videoUrlInput') || {}).value || '';
  if (!url.trim()) return alert('‡§µ‡•Ä‡§°‡§ø‡§Ø‡•ã URL ‡§°‡§æ‡§≤‡•á‡§Ç');
  videoRef.update({ url })
    .then(() => alert('‡§µ‡•Ä‡§°‡§ø‡§Ø‡•ã URL ‡§∏‡•á‡§µ ‚úÖ'))
    .catch(e => alert("Error updating video URL: " + e.message));
}

async function toggleVideo() {
  if (!db) return alert("Firebase not initialized.");
  const snap = await videoRef.once('value');
  const d = snap.val() || {};
  const isPlaying = !d.isPlaying;
  await videoRef.update({ isPlaying })
    .catch(e => alert("Error toggling video: " + e.message));
}

function blankSlide() {
  return { src: '', linkUrl: '', title: '', buttonText: '', buttonUrl: '', width: '', height: '' };
}

function renderSlidesTable() {
  const tbody = document.getElementById('slidesTbody');
  if (!tbody) return;
  tbody.innerHTML = '';
  localSlides.forEach((s, i) => {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td class="row-actions">
        <button onclick="moveSlide(${i}, -1)">‚Üë</button>
        <button onclick="moveSlide(${i}, 1)">‚Üì</button>
        <button onclick="deleteSlide(${i})">üóë</button>
      </td>
      <td><input class="w-220" placeholder="Image URL" value="${escapeHtml(s.src)}" oninput="onCellChange(${i}, 'src', this.value)"></td>
      <td><input class="w-220" placeholder="Link URL (image click)" value="${escapeHtml(s.linkUrl || '')}" oninput="onCellChange(${i}, 'linkUrl', this.value)"></td>
      <td><input class="w-220" placeholder="Title / Text (overlay)" value="${escapeHtml(s.title || '')}" oninput="onCellChange(${i}, 'title', this.value)"></td>
      <td>
        <input class="w-160" placeholder="Button Text" value="${escapeHtml(s.buttonText || '')}" oninput="onCellChange(${i}, 'buttonText', this.value)">
        <input class="w-220" placeholder="Button Link URL" value="${escapeHtml(s.buttonUrl || '')}" oninput="onCellChange(${i}, 'buttonUrl', this.value)">
      </td>
      <td>
        <input class="w-120" type="number" min="0" placeholder="Width (px)" value="${escapeHtml(s.width || '')}" oninput="onCellChange(${i}, 'width', this.value)">
        <input class="w-120" type="number" min="0" placeholder="Height (px)" value="${escapeHtml(s.height || '')}" oninput="onCellChange(${i}, 'height', this.value)">
      </td>
    `;
    tbody.appendChild(tr);
  });
  document.getElementById('slidesCount').innerText = localSlides.length;
}

function onCellChange(i, key, val) {
  localSlides[i][key] = val;
}

function addSlideRow() {
  localSlides.push(blankSlide());
  renderSlidesTable();
}

function deleteSlide(i) {
  if (!confirm('Delete this slide?')) return;
  localSlides.splice(i, 1);
  renderSlidesTable();
}

function moveSlide(i, dir) {
  const j = i + dir;
  if (j < 0 || j >= localSlides.length) return;
  const tmp = localSlides[i];
  localSlides[i] = localSlides[j];
  localSlides[j] = tmp;
  renderSlidesTable();
}

function saveSlidesAdvanced() {
  if (!db) return alert("Firebase not initialized.");
  const cleaned = localSlides
    .map(s => ({
      src: (s.src || '').trim(),
      linkUrl: (s.linkUrl || '').trim(),
      title: (s.title || '').trim(),
      buttonText: (s.buttonText || '').trim(),
      buttonUrl: (s.buttonUrl || '').trim(),
      width: s.width !== '' ? Number(s.width) : '',
      height: s.height !== '' ? Number(s.height) : ''
    }))
    .filter(s => s.src);
  if (!cleaned.length) return alert('‡§ï‡§Æ-‡§∏‡•á-‡§ï‡§Æ ‡§è‡§ï slide ‡§ï‡§æ Image URL ‡§≠‡§∞‡•á‡§Ç');
  sliderRef.update({ slides: cleaned })
    .then(() => alert('Slides updated ‚úÖ'))
    .catch(e => alert('Error updating slides: ' + e.message));
}

async function toggleSliderPlay() {
  if (!db) return alert("Firebase not initialized.");
  const snap = await sliderRef.once('value');
  const data = snap.val() || {};
  const newState = !data.isPlaying;
  await sliderRef.update({ isPlaying: newState })
    .catch(e => alert('Error toggling slider: ' + e.message));
}

function nextSlide() {
  if (!db) return alert("Firebase not initialized.");
  sliderRef.child('currentIndex').transaction(i => (typeof i === 'number' ? i : 0) + 1)
    .catch(e => alert('Error advancing slide: ' + e.message));
}

function prevSlide() {
  if (!db) return alert("Firebase not initialized.");
  sliderRef.child('currentIndex').transaction(i => {
    const cur = (typeof i === 'number' ? i : 0);
    return cur - 1;
  }).catch(e => alert('Error going to previous slide: ' + e.message));
}

function goToSlide() {
  if (!db) return alert("Firebase not initialized.");
  const idx = parseInt((document.getElementById('gotoIndexInput') || {}).value) || 0;
  sliderRef.update({ currentIndex: idx })
    .catch(e => alert('Error setting slide index: ' + e.message));
}

function setSpeed() {
  if (!db) return alert("Firebase not initialized.");
  const ms = parseInt((document.getElementById('speedInput') || {}).value) || 0;
  if (ms < 500) return alert('Minimum 500 ms');
  sliderRef.update({ speedMs: ms })
    .catch(e => alert('Error setting slider speed: ' + e.message));
}

function startGame(key) {
  if (!db) return alert("Firebase not initialized.");
  const ref = refFor(key);
  if (!ref) return alert('Invalid game key');
  ref.update({ status: 'started', liveNumber: null, history: [], startTime: new Date().toISOString(), claims: null, winners: null, tickets: null }) // Added tickets: null to ensure start game also clears tickets
    .then(() => {
      updateStatusUI(key, 'started');
      alert(key + ' started ‚úÖ');
    })
    .catch(e => alert('Error starting game: ' + e.message));
}

function stopGame(key) {
  if (!db) return alert("Firebase not initialized.");
  const ref = refFor(key);
  if (!ref) return alert('Invalid game key');
  clearInterval(autoTimers[key]);
  clearInterval(countdownIntervals[key]);
  ref.update({ status: 'stopped', stopTime: new Date().toISOString(), countdown: 0 })
    .then(() => {
      updateStatusUI(key, 'stopped');
      alert(key + ' stopped ‚èπ');
    })
    .catch(e => alert('Error stopping game: ' + e.message));
}

// --- UPDATED resetGame function to clear global claims also ---
function resetGame(key) {
  if (!db) return alert("Firebase not initialized.");
  const ref = refFor(key);
  if (!ref) return alert('Invalid game key');
  clearInterval(autoTimers[key]);
  clearInterval(countdownIntervals[key]);

  const gameResetPromise = ref.update({
    status: 'idle', liveNumber: null, countdown: null, ticketsLeft: null, totalSpots: null, history: null, winners: null, claims: null, tickets: null
  }).then(() => {
    clearBoardHighlights(key);
    updateStatusUI(key, 'idle');
    return `${key} reset to idle üîÑ`;
  }).catch(e => {
    console.error(`Error resetting game ${key}:`, e);
    return `Error resetting game ${key}: ${e.message}`;
  });

  // Also clear global claims to resolve any residual "already claimed" issues
  const claimsClearPromise = globalClaimsRef.remove()
    .then(() => 'Global claims cleared successfully.')
    .catch(e => {
      console.error("Error clearing global claims in reset:", e);
      return `Error clearing global claims: ${e.message}`;
    });

  Promise.all([gameResetPromise, claimsClearPromise])
    .then(results => {
      alert(`Reset Complete for ${key}.\n\nDetails: \n` + results.join('\n'));
    });
}
// --- END UPDATED resetGame function ---

function updateStatusUI(key, value) {
  const el = document.getElementById(`${key}StatusDisplay`);
  if (el) el.innerText = value;
}

function clearBoardHighlights(game) {
  const id = (game === 'current') ? 'currentTambolaBoard' : (game === 'next') ? 'nextTambolaBoard' : 'friendsTambolaBoard';
  const board = document.getElementById(id);
  if (!board) return;
  Array.from(board.children).forEach(c => c.classList.remove('drawn'));
}

function broadcastNumber(game = 'current') {
  if (!db) return alert("Firebase not initialized.");
  const inputId = (game === 'current') ? 'currentNumberInput' : (game === 'next') ? 'nextNumberInput' : 'friendsNumberInput';
  const val = parseInt(document.getElementById(inputId).value);
  if (!val || val < 1 || val > 90) return alert('Enter number 1-90');
  const r = refFor(game);
  r.update({ liveNumber: val })
    .then(() => {
      r.child('history').transaction(hist => {
        const historyArr = hist || [];
        if (!historyArr.includes(val)) {
          historyArr.push(val);
        }
        return historyArr;
      });
    })
    .catch(e => alert('Error broadcasting number: ' + e.message));
}

function autoDrawNumber(game = 'current') {
  if (!db) return alert("Firebase not initialized.");
  clearInterval(autoTimers[game]);
  const r = refFor(game);
  autoTimers[game] = setInterval(() => {
    r.child('history').transaction(historyArr => {
      const hist = historyArr || [];
      const drawnNumbers = new Set(hist);
      const availableNumbers = Array.from({ length: 90 }, (_, i) => i + 1).filter(num => !drawnNumbers.has(num));
      if (availableNumbers.length > 0) {
        const num = availableNumbers[Math.floor(Math.random() * availableNumbers.length)];
        r.child('liveNumber').set(num);
        hist.push(num);
      } else {
        clearInterval(autoTimers[game]);
        alert("All numbers drawn! Auto-draw stopped.");
      }
      return hist;
    }).catch(e => console.error(`Error in auto-draw for ${game}:`, e));
  }, 30000);
  alert("Auto-draw started for " + game + " every 30 seconds.");
}

function generateBoard(game = 'current') {
  const boardId = (game === 'current') ? 'currentTambolaBoard' : (game === 'next') ? 'nextTambolaBoard' : 'friendsTambolaBoard';
  const board = document.getElementById(boardId);
  if (!board) return;
  board.innerHTML = '';
  for (let i = 1; i <= 90; i++) {
    const cell = document.createElement('div');
    cell.className = 'board-cell';
    cell.id = game + 'Cell' + i;
    cell.innerText = i;
    board.appendChild(cell);
  }
}

function highlightNumber(game, num) {
  const el = document.getElementById(game + 'Cell' + num);
  if (el) el.classList.add('drawn');
}

function updatePrize(game) {
  if (!db) return alert("Firebase not initialized.");
  const id = (game === 'current') ? 'currentPrizeInput' : (game === 'next') ? 'nextPrizeInput' : 'friendsPrizeInput';
  const v = parseInt(document.getElementById(id).value) || 0;
  if (v < 1 || v > 100) return alert('Enter % between 1-100');
  refFor(game).child('prizePercentage').set(v)
    .then(() => alert('Prize percentage updated for ' + game + ' ‚úÖ'))
    .catch(e => alert('Error updating prize percentage: ' + e.message));
}

function updateTickets(game) {
  if (!db) return alert("Firebase not initialized.");
  const id = (game === 'current') ? 'currentTicketsInput' : (game === 'next') ? 'nextTicketsInput' : 'friendsTicketsInput';
  const v = parseInt(document.getElementById(id).value) || 0;
  refFor(game).child('ticketsLeft').set(v)
    .then(() => alert('Tickets updated for ' + game + ' ‚úÖ'))
    .catch(e => alert('Error updating tickets: ' + e.message));
}

function updateSpots(game) {
  if (!db) return alert("Firebase not initialized.");
  const id = (game === 'current') ? 'currentSpotsInput' : (game === 'next') ? 'nextSpotsInput' : 'friendsSpotsInput';
  const v = parseInt(document.getElementById(id).value) || 0;
  refFor(game).child('totalSpots').set(v)
    .then(() => alert('Spots updated for ' + game + ' ‚úÖ'))
    .catch(e => alert('Error updating spots: ' + e.message));
}

function updateCountdown(key) {
  if (!db) return alert("Firebase not initialized.");
  const hours = parseInt(document.getElementById(key + 'CountdownInput_h').value) || 0;
  const minutes = parseInt(document.getElementById(key + 'CountdownInput_m').value) || 0;
  const seconds = parseInt(document.getElementById(key + 'CountdownInput_s').value) || 0;

  const totalSeconds = (hours * 3600) + (minutes * 60) + seconds;

  if (totalSeconds < 5) {
    return alert('Countdown must be at least 5 seconds.');
  }
  startCountdown(key, totalSeconds);
}

function loadWinnersForm(game = 'current') {
  const formId = (game === 'current') ? 'currentWinnersForm' : (game === 'next') ? 'nextWinnersForm' : 'friendsWinnersForm';
  let html = '';
  for (let i = 1; i <= 10; i++) {
    html += `<div class="winner-card">
      <b>Winner #${i}</b><br>
      Name: <input id="${game}Name${i}" placeholder="Name"><br>
      Phone: <input id="${game}Phone${i}" placeholder="Phone"><br>
      Prize (‚Çπ): <input id="${game}Prize${i}" type="number"><br>
    </div>`;
  }
  document.getElementById(formId).innerHTML = html;
}

function saveAllWinners(game) {
  if (!db) return alert("Firebase not initialized.");
  const ref = refFor(game).child('winners');
  let payload = {};
  for (let i = 1; i <= 10; i++) {
    const name = document.getElementById(game + 'Name' + i).value.trim();
    const phone = document.getElementById(game + 'Phone' + i).value.trim();
    const prize = parseInt(document.getElementById(game + 'Prize' + i).value) || 0;
    if (!name || !phone) { alert('Enter Name & Phone for Winner #' + i); return; }
    payload['winner' + i] = { name, phone, prize };
  }
  ref.set(payload)
    .then(() => {
      alert('All winners saved for ' + game + ' ‚úÖ');
    })
    .catch(e => alert('Error saving winners: ' + e.message));
}

function sendNotification() {
  if (!db) return alert("Firebase not initialized.");
  const msg = (document.getElementById('notifyMessage') || {}).value || '';
  const to = (document.getElementById('notifyTo') || {}).value || '';
  const broadcast = document.getElementById('notifyBroadcast') && document.getElementById('notifyBroadcast').checked;
  if (!msg.trim()) return alert('Enter message');
  const payload = { message: msg.trim(), time: new Date().toISOString(), from: 'admin' };
  if (broadcast) {
    db.ref('notifications').push({ message: msg.trim(), time: firebase.database.ServerValue.TIMESTAMP })
      .then(() => {
        alert('Broadcast notification sent ‚úÖ');
        document.getElementById('notifyMessage').value = '';
        document.getElementById('notifyTo').value = '';
        if (document.getElementById('notifyBroadcast')) document.getElementById('notifyBroadcast').checked = false;
      })
      .catch(e => alert('Error sending broadcast notification: ' + e.message));
  } else if (to.trim()) {
    db.ref('userNotifications').child(to.trim()).push({ message: msg.trim(), time: firebase.database.ServerValue.TIMESTAMP })
      .then(() => {
        alert('Notification sent to ' + to.trim() + ' ‚úÖ');
        document.getElementById('notifyMessage').value = '';
        document.getElementById('notifyTo').value = '';
      })
      .catch(e => alert('Error sending notification: ' + e.message));
  } else {
    db.ref('notifications').push({ message: msg.trim(), time: firebase.database.ServerValue.TIMESTAMP })
      .then(() => {
        alert('Notification pushed to notifications (no target) ‚úÖ');
        document.getElementById('notifyMessage').value = '';
        document.getElementById('notifyTo').value = '';
      })
      .catch(e => alert('Error sending notification: ' + e.message));
  }
}

function fillRooms() {
  const select = document.getElementById('roomDropdown');
  select.innerHTML = '';
  for (let i = 1; i <= 1000; i++) {
    const opt = document.createElement('option');
    opt.value = 'Room' + i;
    opt.innerText = 'Room ' + i;
    select.appendChild(opt);
  }
  select.value = selectedRoom;
}

function filterRooms() {
  const q = (document.getElementById('roomSearch') || {}).value.toLowerCase();
  const select = document.getElementById('roomDropdown');
  Array.from(select.options).forEach(opt => {
    opt.style.display = opt.text.toLowerCase().includes(q) ? '' : 'none';
  });
}

function changeRoom() {
  if (!db) return alert("Firebase not initialized.");
  const sel = document.getElementById('roomDropdown').value || 'Room1';
  
  if (sel === selectedRoom) return;

  for (const key in listeners.friends) {
    if (listeners.friends[key]) {
      friendsGameRef.child(key).off('value', listeners.friends[key]);
    }
  }

  selectedRoom = sel;
  friendsGameRef = roomsRef.child(selectedRoom);
  alert('Now controlling ' + selectedRoom);
  generateBoard('friends');
  loadGameData('friends');
}

function approveClaim(id) {
  if (!db) return alert("Firebase not initialized.");
  // NOTE: This assumes the claim ID 'id' is the global claims ID, and not just the game-specific one.
  db.ref('claims/' + id).update({ status: 'approved', reviewedBy: 'admin', reviewedAt: new Date().toISOString() })
    .then(() => {
      db.ref('claims/' + id).once('value').then(snap => {
        const c = snap.val() || {};
        if (c.userId) {
          db.ref('userNotifications').child(c.userId).push({ 
            message: `Your claim for ${c.prize} has been approved`, 
            time: firebase.database.ServerValue.TIMESTAMP, 
            from: 'admin' 
          });
        }
        alert('Claim approved ‚úÖ');
      });
    })
    .catch(e => alert('Error approving claim: ' + e.message));
}

function rejectClaim(id) {
  if (!db) return alert("Firebase not initialized.");
  // NOTE: This assumes the claim ID 'id' is the global claims ID, and not just the game-specific one.
  db.ref('claims/' + id).update({ status: 'rejected', reviewedBy: 'admin', reviewedAt: new Date().toISOString() })
    .then(() => {
      db.ref('claims/' + id).once('value').then(snap => {
        const c = snap.val() || {};
        if (c.userId) {
          db.ref('userNotifications').child(c.userId).push({ 
            message: `Your claim for ${c.prize} was rejected`, 
            time: firebase.database.ServerValue.TIMESTAMP, 
            from: 'admin' 
          });
        }
        alert('Claim rejected ‚ùå');
      });
    })
    .catch(e => alert('Error rejecting claim: ' + e.message));
}

function approveWithdraw(id) {
  if (!db) return alert("Firebase not initialized.");
  const wRef = db.ref('withdrawals/' + id);
  wRef.once('value').then(snap => {
    const w = snap.val() || {};
    wRef.update({ status: 'approved', reviewedBy: 'admin', reviewedAt: new Date().toISOString() })
      .then(() => {
        if (w.userId) {
          db.ref('userNotifications').child(w.userId).push({ 
            message: `Your withdrawal ‚Çπ${w.amount} approved`, 
            time: firebase.database.ServerValue.TIMESTAMP, 
            from: 'admin' 
          });
        }
        alert('Withdrawal approved ‚úÖ');
      })
      .catch(e => alert('Error approving withdrawal: ' + e.message));
  }).catch(e => alert('Error fetching withdrawal: ' + e.message));
}

function rejectWithdrawPrompt(id) {
  if (!db) return alert("Firebase not initialized.");
  const reason = prompt('Enter rejection reason (optional):', '');
  if (reason === null) return;
  rejectWithdraw(id, reason);
}

function rejectWithdraw(id, reason) {
  if (!db) return alert("Firebase not initialized.");
  const wRef = db.ref('withdrawals/' + id);
  wRef.once('value').then(snap => {
    const w = snap.val() || {};
    wRef.update({ status: 'rejected', reviewedBy: 'admin', reviewedAt: new Date().toISOString(), rejectionReason: reason || '' })
      .then(() => {
        if (w.userId) {
          db.ref('userNotifications').child(w.userId).push({ 
          message: `Your withdrawal ‚Çπ${w.amount} was rejected: ${reason || 'No reason'}`, 
            time: firebase.database.ServerValue.TIMESTAMP, 
            from: 'admin' 
          });
        }
        alert('Withdrawal rejected ‚ùå');
      })
      .catch(e => alert('Error rejecting withdrawal: ' + e.message));
  }).catch(e => alert('Error fetching withdrawal: ' + e.message));
}

function viewWithdraw(id) {
  if (!db) return alert("Firebase not initialized.");
  db.ref('withdrawals/' + id).once('value').then(snap => {
    const w = snap.val() || {};
    alert(`User: ${w.userId}\nAmount: ‚Çπ${w.amount}\nDestination: ${w.dest}\nStatus: ${w.status}\nRequested: ${new Date(w.time).toLocaleString() || ''}\nReason: ${w.rejectionReason || ''}`);
  }).catch(e => alert('Error viewing withdrawal: ' + e.message));
}

function renderPrizeInputs() {
  if (!db) {
    document.getElementById('prizeManagementContainer').innerHTML = '<div class="muted">Firebase not initialized. Prize management unavailable.</div>';
    return;
  }
  prizesRef.once('value').then(snap => {
    const prizes = snap.val() || {};
    const prizeNames = ['Early Five', 'Ticket Corner', 'Each Line', 'Full House', '2nd Full House'];
    const container = document.getElementById('prizeManagementContainer');
    let html = '';
    prizeNames.forEach(prize => {
      const currentAmount = prizes[prize] !== undefined ? prizes[prize] : '';
      html += `
        <div style="margin: 8px 0;">
          <label style="font-weight:bold;display:block;margin-bottom:4px;">${prize} Prize (‚Çπ)</label>
          <input type="number" id="prizeInput_${prize.replace(/\s/g, '_')}" value="${currentAmount}" placeholder="Enter amount" min="0" step="1">
        </div>
      `;
    });
    container.innerHTML = html;
    document.getElementById('prizeUpdateMessage').innerText = 'Prizes loaded successfully.';
  }).catch(e => {
    console.error('Error fetching prizes:', e);
    document.getElementById('prizeUpdateMessage').innerText = 'Error loading prizes: ' + e.message;
  });
}

function savePrizes() {
  if (!db) return alert("Firebase not initialized.");
  const prizeNames = ['Early Five', 'Ticket Corner', 'Each Line', 'Full House', '2nd Full House'];
  const updates = {};
  let hasValidInput = false;

  prizeNames.forEach(prize => {
    const input = document.getElementById(`prizeInput_${prize.replace(/\s/g, '_')}`);
    const value = input.value.trim();
    const amount = value ? parseInt(value) : null;

    if (value && (isNaN(amount) || amount < 0)) {
      alert(`Invalid amount for ${prize}. Please enter a non-negative number or leave empty.`);
      document.getElementById('prizeUpdateMessage').innerText = `Invalid amount for ${prize}.`;
      throw new Error(`Invalid amount for ${prize}`);
    }

    updates[prize] = amount !== null ? amount : null;
    if (amount !== null) hasValidInput = true;
  });

  if (!hasValidInput) {
    alert('Please set at least one prize amount.');
    document.getElementById('prizeUpdateMessage').innerText = 'Please set at least one prize amount.';
    return;
  }

  prizesRef.update(updates)
    .then(() => {
      document.getElementById('prizeUpdateMessage').innerText = 'Prizes updated successfully! ‚úÖ';
      setTimeout(() => {
        document.getElementById('prizeUpdateMessage').innerText = '';
      }, 3000);
    })
    .catch(e => {
      console.error('Error updating prizes:', e);
      document.getElementById('prizeUpdateMessage').innerText = `Error updating prizes: ${e.message}. Please check Firebase configuration and rules.`;
    });
}

function toggleClaimsView() {
  showAllClaims = !showAllClaims;
  const button = document.getElementById('toggleClaimsButton');
  button.innerText = showAllClaims ? 'Show Latest Claim' : 'View All Claims';
  renderClaims();
}

function renderClaims() {
  if (!db) {
    document.getElementById('claimsList').innerHTML = '<div class="muted">Firebase not initialized. Claims unavailable.</div>';
    return;
  }
  globalClaimsRef.once('value').then(snap => { // Using globalClaimsRef
    const data = snap.val() || {};
    const claims = Object.keys(data).map(id => ({
      id,
      ...data[id],
      time: data[id].time || 0
    }));
    let html = '';
    if (showAllClaims) {
      claims.forEach(c => {
        const status = c.status || 'pending';
        // Note: I'm using c.gameKey here, assuming 'gameId' might not be the exact key, but you should adjust based on your Firebase structure (e.g., c.gameKey || 'N/A')
        html += `<div class="claim-card">
          <div style="flex:1">
            <div><b>User:</b> ${escapeHtml(c.userName || c.userId || 'Unknown')}</div>
            <div class="muted"><b>Prize:</b> ${escapeHtml(c.prize || 'claim')}</div>
            <div class="muted"><b>Game:</b> ${escapeHtml(c.gameKey || 'N/A')}</div>
            <div class="muted"><b>Time:</b> ${escapeHtml(new Date(c.time).toLocaleString() || '')}</div>
            <div class="muted"><b>Status:</b> ${escapeHtml(status)}</div>
          </div>
          <div style="display:flex;flex-direction:column;gap:6px">
            <button type="button" onclick="approveClaim('${c.id}')" ${status !== 'pending' ? 'disabled' : ''}>‚úÖ Approve</button>
            <button type="button" onclick="rejectClaim('${c.id}')" ${status !== 'pending' ? 'disabled' : ''}>‚ùå Reject</button>
          </div>
        </div>`;
      });
    } else {
      const latestClaim = claims.sort((a, b) => b.time - a.time)[0];
      if (latestClaim) {
        const status = latestClaim.status || 'pending';
        html = `<div class="claim-card">
          <div style="flex:1">
            <div><b>User:</b> ${escapeHtml(latestClaim.userName || latestClaim.userId || 'Unknown')}</div>
            <div class="muted"><b>Prize:</b> ${escapeHtml(latestClaim.prize || 'claim')}</div>
            <div class="muted"><b>Game:</b> ${escapeHtml(latestClaim.gameKey || 'N/A')}</div>
            <div class="muted"><b>Time:</b> ${escapeHtml(new Date(latestClaim.time).toLocaleString() || '')}</div>
            <div class="muted"><b>Status:</b> ${escapeHtml(status)}</div>
          </div>
          <div style="display:flex;flex-direction:column;gap:6px">
            <button type="button" onclick="approveClaim('${latestClaim.id}')" ${status !== 'pending' ? 'disabled' : ''}>‚úÖ Approve</button>
            <button type="button" onclick="rejectClaim('${latestClaim.id}')" ${status !== 'pending' ? 'disabled' : ''}>‚ùå Reject</button>
          </div>
        </div>`;
      }
    }
    document.getElementById('claimsList').innerHTML = html || '<div class="muted">No claims yet</div>';
  }).catch(e => {
    console.error('Error fetching claims:', e);
    document.getElementById('claimsList').innerHTML = `<div class="muted">Error loading claims: ${e.message}</div>`;
  });
}

function escapeHtml(str) {
  return String(str || '').replace(/[&<>"'`]/g, s => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;', '`': '&#96;' })[s]);
}

function bindGlobalListeners() {
  if (!db) {
    console.warn("Firebase not initialized. Skipping global listeners.");
    return;
  }
  musicRef.on("value", snap => {
    const data = snap.val() || {};
    const urlInput = document.getElementById("musicUrlInput");
    const tBtn = document.getElementById("toggleMusicBtn");
    if (urlInput) urlInput.value = data.url || "";
    if (tBtn) tBtn.innerText = data.isPlaying ? "‚è∏ Pause" : "‚ñ∂Ô∏è Play";
  });

  videoRef.on("value", snap => {
    const d = snap.val() || {};
    const urlInput = document.getElementById('videoUrlInput');
    const tBtn = document.getElementById('toggleVideoBtn');
    if (urlInput) urlInput.value = d.url || '';
    if (tBtn) tBtn.innerText = d.isPlaying ? '‚è∏ ‡§™‡•â‡§ú‡§º' : '‚ñ∂Ô∏è ‡§™‡•ç‡§≤‡•á';
  });

  sliderRef.on('value', snap => {
    const d = snap.val() || {};
    localSlides = Array.isArray(d.slides) ? JSON.parse(JSON.stringify(d.slides)) : [];
    renderSlidesTable();
    const tBtn = document.getElementById('toggleSliderBtn');
    if (tBtn) tBtn.innerText = d.isPlaying ? '‚è∏ Pause' : '‚ñ∂Ô∏è Play';
    const idxDisp = document.getElementById('currentIndexDisplay');
    if (idxDisp) idxDisp.innerText = (typeof d.currentIndex === 'number' ? d.currentIndex : 0);
    const spDisp = document.getElementById('speedDisplay');
    if (spDisp) spDisp.innerText = (d.speedMs || 0) + ' ms';
  });

  if (!listeners.globalClaims) {
    listeners.globalClaims = globalClaimsRef.on('value', () => { // Using globalClaimsRef
      renderClaims();
    });
  }

  if (!listeners.globalWithdrawals) {
    listeners.globalWithdrawals = db.ref('withdrawals').on('value', snap => {
      const data = snap.val() || {};
      let rows = '';
      Object.keys(data).forEach(id => {
        const w = data[id];
        const status = w.status || 'pending';
        const requested = w.time ? new Date(w.time).toLocaleString() : '';
        rows += `<tr>
          <td><b>${escapeHtml(w.name || 'unknown')}</b><div class="muted">${escapeHtml(w.userId)}</div></td>
          <td>‚Çπ${escapeHtml(w.amount || 0)}</td>
          <td>${escapeHtml(w.dest || '--')}</td>
          <td>${escapeHtml(status)}</td>
          <td>${requested}</td>
          <td>
            ${status === 'pending' ? `<button onclick="approveWithdraw('${id}')" class="btn-ghost">Approve</button>
            <button onclick="rejectWithdrawPrompt('${id}')" class="btn-danger">Reject</button>` : `<button class="btn-ghost" onclick="viewWithdraw('${id}')">View</button>`}
          </td>
        </tr>`;
      });
      if (!rows) rows = '<tr><td colspan="6" class="muted">No withdrawal requests</td></tr>';
      document.getElementById('withdrawalsList').innerHTML = `<table class="table-small"><thead><tr><th>User</th><th>Amount</th><th>Destination</th><th>Status</th><th>Requested</th><th>Action</th></tr></thead><tbody>${rows}</tbody></table>`;
    });
  }

  if (!listeners.globalUsers) {
    listeners.globalUsers = db.ref('users').on('value', snap => {
      const data = snap.val() || {};
      let rows = '';
      Object.keys(data).forEach(uid => {
        const u = data[uid] || {};
        rows += `<tr>
          <td><b>${escapeHtml(uid)}</b><div class="muted">${escapeHtml(u.name || '')}</div></td>
          <td>‚Çπ${u.balance || 0}</td>
        </tr>`;
      });
      if (!rows) rows = '<tr><td colspan="2" class="muted">No users found</td></tr>';
      document.getElementById('usersTicketsList').innerHTML = `<table class="table-small"><thead><tr><th>User ID</th><th>Balance</th></tr></thead><tbody>${rows}</tbody></table>`;
    });
  }

  presenceRef.on('value', snap => {
    const count = snap.numChildren();
    document.getElementById('liveUserCountDisplay').textContent = count;
  });
  
  // **LIVE TICKET SOLD COUNT LISTENER**
  db.ref('userTickets').on('value', snap => {
    let totalCount = 0;
    if (snap.exists()) {
      snap.forEach(userNode => {
        userNode.forEach(ticketNode => {
             totalCount++;
        });
      });
    }
    document.getElementById('totalTicketsSoldDisplay').textContent = totalCount;
  });
  // **END LIVE TICKET SOLD COUNT LISTENER**
}

function loadGameData(game) {
  if (!db) {
    console.warn(`Firebase not initialized. Skipping game data load for ${game}.`);
    return;
  }
  const gameRef = refFor(game);

  for (const key in listeners[game]) {
    gameRef.child(key).off('value', listeners[game][key]);
  }
  listeners[game] = {};

  const gameDataListener = gameRef.on('value', snap => {
    const data = snap.val() || {};
    
    const statusEl = document.getElementById(`${game}StatusDisplay`);
    if (statusEl) statusEl.innerText = data.status || 'idle';

    const prizeInputEl = document.getElementById(`${game}PrizeInput`);
    if (prizeInputEl) prizeInputEl.value = data.prizePercentage || 0;
    const prizeDisplayEl = document.getElementById(`${game}PrizeDisplay`);
    if (prizeDisplayEl) prizeDisplayEl.innerText = (data.prizePercentage || 0) + '%';
    
    const ticketsInputEl = document.getElementById(`${game}TicketsInput`);
    if (ticketsInputEl) ticketsInputEl.value = data.ticketsLeft || 0;
    const ticketsDisplayEl = document.getElementById(`${game}TicketsDisplay`);
    if (ticketsDisplayEl) ticketsDisplayEl.innerText = data.ticketsLeft || 0;

    const spotsInputEl = document.getElementById(`${game}SpotsInput`);
    if (spotsInputEl) spotsInputEl.value = data.totalSpots || 0;
    const spotsDisplayEl = document.getElementById(`${game}SpotsDisplay`);
    if (spotsDisplayEl) spotsDisplayEl.innerText = data.totalSpots || 0;
    
    const countdownDisplayEl = document.getElementById(`${game}CountdownDisplay`);
    const countdownValue = data.countdown || 0;
    if (countdownDisplayEl) {
      const h = Math.floor(countdownValue / 3600);
      const m = Math.floor((countdownValue % 3600) / 60);
      const s = countdownValue % 60;
      countdownDisplayEl.innerText = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
    }
  });
  listeners[game].gameData = gameDataListener;

  const winnersListener = gameRef.child('winners').on('value', snap => {
    const winners = snap.val() || {};
    for (let i = 1; i <= 10; i++) {
      const winner = winners[`winner${i}`] || {};
      const nameInput = document.getElementById(`${game}Name${i}`);
      const phoneInput = document.getElementById(`${game}Phone${i}`);
      const prizeInput = document.getElementById(`${game}Prize${i}`);
      if (nameInput) nameInput.value = winner.name || '';
      if (phoneInput) phoneInput.value = winner.phone || '';
      if (prizeInput) prizeInput.value = winner.prize || 0;
    }
  });
  listeners[game].winners = winnersListener;

  const claimsListId = `${game}ClaimsList`;
  const claimsList = document.getElementById(claimsListId);
  if (claimsList) {
    const claimsListener = gameRef.child('claims').on('value', snap => {
      const data = snap.val() || {};
      let html = '';
      Object.keys(data).forEach(id => {
        const c = data[id];
        const status = c.status || 'pending';
        // Note: Assuming these game-specific claims have the necessary info
        html += `<div class="claim-card">
          <div style="flex:1">
            <div><b>User:</b> ${escapeHtml(c.userName || c.userId || 'Unknown')}</div>
            <div class="muted"><b>Prize:</b> ${escapeHtml(c.prize || 'claim')}</div>
            <div class="muted"><b>Game:</b> ${escapeHtml(game)}</div>
            <div class="muted"><b>Time:</b> ${escapeHtml(new Date(c.time).toLocaleString() || '')}</div>
            <div class="muted"><b>Status:</b> ${escapeHtml(status)}</div>
          </div>
          <div style="display:flex;flex-direction:column;gap:6px">
            <button type="button" onclick="approveClaim('${id}')" ${status !== 'pending' ? 'disabled' : ''}>‚úÖ Approve</button>
            <button type="button" onclick="rejectClaim('${id}')" ${status !== 'pending' ? 'disabled' : ''}>‚ùå Reject</button>
          </div>
        </div>`;
      });
      claimsList.innerHTML = html || '<div class="muted">No claims for this game yet.</div>';
    });
    listeners[game].claims = claimsListener;
  }
  
  // **TICKET LISTENER FOR VIEW ALL SOLD TICKETS**
  const ticketsListId = `${game}TicketsList`;
  const ticketsList = document.getElementById(ticketsListId);
  if (ticketsList) {
    const ticketsListener = gameRef.child('tickets').on('value', snap => {
      const tickets = snap.val() || {};
      let html = '';
      if (Object.keys(tickets).length > 0) {
        Object.keys(tickets).forEach(userId => {
          const userTickets = tickets[userId];
          const validTickets = Object.values(userTickets || {}).filter(t => t && t.ticketId && Array.isArray(t.numbers));

          if (validTickets.length > 0) {
              html += `<div style="margin-top:10px;"><b>User ID: ${escapeHtml(userId)} (${validTickets.length} tickets)</b></div>`;
              validTickets.forEach(ticket => {
                html += `<div style="border:1px solid #444; padding:8px; margin-top:5px; border-radius:6px;">`;
                html += `Ticket ID: ${escapeHtml(ticket.ticketId)}<br>`;
                html += `Numbers: ${escapeHtml(ticket.numbers.join(', '))}`;
                html += `</div>`;
              });
          }
        });
      }
      ticketsList.innerHTML = html || '<div class="muted">No tickets purchased for this game yet.</div>';
    });
    listeners[game].tickets = ticketsListener;
  }
  // **END TICKET LISTENER**
  
  const historyListener = gameRef.child('history').on('value', snap => {
    const history = snap.val() || [];
    clearBoardHighlights(game);
    history.forEach(num => highlightNumber(game, num));
  });
  listeners[game].history = historyListener;
}

window.onload = function() {
  console.log("Window loaded, starting animation...");
  const loadingScreen = document.getElementById('loading-screen');
  const mainContent = document.getElementById('main-content');

  if (!loadingScreen || !mainContent) {
    console.error("Loading screen or main content not found.");
    alert("Error: Page elements missing. Check HTML structure.");
    mainContent.style.display = 'block'; // Fallback to show content
    document.body.style.overflow = 'auto';
    return;
  }

  // Show loading animation for 3.5 seconds, then transition to main content
  setTimeout(() => {
    console.log("Animation complete, transitioning to main content...");
    loadingScreen.classList.add('hidden');
    mainContent.classList.add('visible');
    document.body.style.overflow = 'auto';
    // Remove loading screen after transition
    setTimeout(() => {
      loadingScreen.style.display = 'none';
      console.log("Loading screen removed.");
    }, 500); // Match transition duration
  }, 3500); // Animation duration

  // Initialize app features
  try {
    ['current', 'next', 'friends'].forEach(g => {
      generateBoard(g);
      loadWinnersForm(g);
      loadGameData(g);
    });
    fillRooms();
    renderPrizeInputs();
    renderClaims();
    bindGlobalListeners();
    console.log("App initialization completed.");
  } catch (e) {
    console.error("Error during app initialization:", e);
    alert("App loaded, but some features may not work due to: " + e.message);
  }
};
</script>
</body>
</html>
